

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://forte-naop.github.io/</id>
  <title>Forte's Notes</title>
  <subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle>
  <updated>2025-01-30T02:06:25+09:00</updated>
  <author>
    <name>Forte</name>
    <uri>https://forte-naop.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://forte-naop.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://forte-naop.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2025 Forte </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>SQL 메모</title>
    <link href="https://forte-naop.github.io/posts/SQL/" rel="alternate" type="text/html" title="SQL 메모" />
    <published>2025-01-30T01:59:01+09:00</published>
  
    <updated>2025-01-30T01:59:01+09:00</updated>
  
    <id>https://forte-naop.github.io/posts/SQL/</id>
    <content type="text/html" src="https://forte-naop.github.io/posts/SQL/" />
    <author>
      <name>Forte</name>
    </author>

  
    
    <category term="Study" />
    
    <category term="Database" />
    
  

  <summary>Database MEMO

SQL 구문 해석 순서


  FROM: 데이터 소스를 지정
  ON: 조인 조건을 설정
  JOIN: 필요한 테이블 결합
  WHERE: 행을 필터링
  GROUP BY: 데이터를 그룹화
  HAVING: 그룹화된 데이터에 추가 조건 적용
  SELECT: 선택한 컬럼을 가져옴
  DISTINCT: 중복된 행 제거
  ORDER BY: 결과를 정렬
  LIMIT: 결과의 개수를 제한


구문 별 문법


  
    
      
        
          LIMIT B, A
          LIMIT A OFFSET B: B번째 행부터 A개의 행 선택 (0-index)
        
      
    
  


ACID</summary>

  </entry>

  
  <entry>
    <title>C++ 정리</title>
    <link href="https://forte-naop.github.io/posts/CPP/" rel="alternate" type="text/html" title="C++ 정리" />
    <published>2025-01-30T01:55:08+09:00</published>
  
    <updated>2025-01-30T01:55:08+09:00</updated>
  
    <id>https://forte-naop.github.io/posts/CPP/</id>
    <content type="text/html" src="https://forte-naop.github.io/posts/CPP/" />
    <author>
      <name>Forte</name>
    </author>

  
    
    <category term="Study" />
    
    <category term="Programming Language" />
    
  

  <summary>C++ 정리

Const


  상수에 관한 키워드


일반 변수에서의 const


  변수 선언시 이후 해당 변수에 대한 변경을 막는다.
  
    const 키워드 이후의 구문에 대한 변경을 막는다고 간주할 수 있다.

    // 기본 자료형(int, float 등)은 무시하고 생각
const int val = 10;
int const val = 10;
// -&amp;amp;gt; val에 대한 변경 금지

const int *val = ...;
// 이후 *val = ...; 금지
// val = ...; 가능

const int **val = ...;
// **val = ...; 금지
// *val = ...; val = ...; 가능

const int * const *val = ...;
// **v...</summary>

  </entry>

  
  <entry>
    <title>최장 공통 부분 수열</title>
    <link href="https://forte-naop.github.io/posts/LCS/" rel="alternate" type="text/html" title="최장 공통 부분 수열" />
    <published>2025-01-30T01:19:44+09:00</published>
  
    <updated>2025-01-30T01:19:44+09:00</updated>
  
    <id>https://forte-naop.github.io/posts/LCS/</id>
    <content type="text/html" src="https://forte-naop.github.io/posts/LCS/" />
    <author>
      <name>Forte</name>
    </author>

  
    
    <category term="Study" />
    
    <category term="Algorithm" />
    
  

  <summary>최장 공통 부분 수열(LCS: Longest Common Subsequence)



LCS 길이 구하기

DP[i][j]: A[..i], B[..j]까지의 LCS길이


  
    A[i] == B[j]: DP[i][j] = DP[i - 1][j - 1] + 1
  
  
    A[i] != B[j]: DP[i][j] = max(DP[i - 1][j], DP[i][j - 1])
  




LCS 문자열 구하기


  역추적 (Backtracking) 방식
DP 테이블을 이용해 (N, M)에서 (0, 0)까지 역추적하여 LCS를 복원.
    
      A[i] == B[j]이면 LCS에 포함됨 → i-1, j-1로 이동
      DP[i-1][j], DP[i][j-1]를 비교해 큰 쪽으로 이...</summary>

  </entry>

  
  <entry>
    <title>정렬 알고리즘</title>
    <link href="https://forte-naop.github.io/posts/Sort/" rel="alternate" type="text/html" title="정렬 알고리즘" />
    <published>2025-01-30T01:15:21+09:00</published>
  
    <updated>2025-01-30T01:15:21+09:00</updated>
  
    <id>https://forte-naop.github.io/posts/Sort/</id>
    <content type="text/html" src="https://forte-naop.github.io/posts/Sort/" />
    <author>
      <name>Forte</name>
    </author>

  
    
    <category term="Study" />
    
    <category term="Algorithm" />
    
  

  <summary>정렬

Bubble Sort

인접한 두 원소를 비교하여 역순이면 교환한다.

# seq = []
# 총 n번 반복
for i in range(n - 1, -1, -1):
    is_swapped = False
    # 매 반복 후에 seq[i + 1:]은 정렬된 상태이므로 
    # seq[:i] 까지만 확인
    for j in range(i):
        if seq[j] &amp;amp;gt; seq[j + 1]:
            seq[j], seq[j + 1] = seq[j + 1] &amp;amp;gt; seq[j]
            is_swapped = True
    if not is_swapped:
        break


Selection Sort

현재 i = [0, n)일 때 seq...</summary>

  </entry>

  
  <entry>
    <title>편집 거리</title>
    <link href="https://forte-naop.github.io/posts/Edit_distance/" rel="alternate" type="text/html" title="편집 거리" />
    <published>2025-01-30T01:02:24+09:00</published>
  
    <updated>2025-01-30T01:02:24+09:00</updated>
  
    <id>https://forte-naop.github.io/posts/Edit_distance/</id>
    <content type="text/html" src="https://forte-naop.github.io/posts/Edit_distance/" />
    <author>
      <name>Forte</name>
    </author>

  
    
    <category term="Study" />
    
    <category term="Algorithm" />
    
  

  <summary>편집 거리

문자열 A를 문자열 B로 바꾸는데 필요한 연산(문자 추가, 삭제, 교체)의 최소 횟수

DP[i][j]: A[..i]를 B[..j]로 편집하는 연산의 최소 횟수

A[i] == B[j]라면 해당 위치에 대해서는 편집할 필요가 없으므로 DP[i][j] == DP[i - 1][j - 1]

A[i] != B[j]라면 편집이 필요하다.

추가하는 경우는 A[i]에 문자열을 하나 추가해서 B[j]가 되어야 하므로 DP[i][j - 1] + 1, 즉 A[..i]를 B[..j - 1]로 변경하는 최소 횟수에 1을 더해준다.

변경은 A[i]를 B[j]로 바꾸는 것이므로 DP[i - 1][j - 1] + 1

삭제는 DP[i - 1][j] + 1이 된다.
(A[..i - 1]로 B[j]를 만들었으므로 ...</summary>

  </entry>

</feed>


