

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://forte-naop.github.io/</id>
  <title>Forte's Notes</title>
  <subtitle>A minimal, responsive and feature-rich Jekyll theme for technical writing.</subtitle>
  <updated>2025-01-30T13:49:38+09:00</updated>
  <author>
    <name>Forte</name>
    <uri>https://forte-naop.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://forte-naop.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://forte-naop.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2025 Forte </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>SQL 메모</title>
    <link href="https://forte-naop.github.io/posts/SQL/" rel="alternate" type="text/html" title="SQL 메모" />
    <published>2024-12-30T01:59:01+09:00</published>
  
    <updated>2024-12-30T01:59:01+09:00</updated>
  
    <id>https://forte-naop.github.io/posts/SQL/</id>
    <content type="text/html" src="https://forte-naop.github.io/posts/SQL/" />
    <author>
      <name>Forte</name>
    </author>

  
    
    <category term="Study" />
    
    <category term="Database" />
    
  

  <summary>Database MEMO

SQL 구문 해석 순서


  FROM: 데이터 소스를 지정
  ON: 조인 조건을 설정
  JOIN: 필요한 테이블 결합
  WHERE: 행을 필터링
  GROUP BY: 데이터를 그룹화
  HAVING: 그룹화된 데이터에 추가 조건 적용
  SELECT: 선택한 컬럼을 가져옴
  DISTINCT: 중복된 행 제거
  ORDER BY: 결과를 정렬
  LIMIT: 결과의 개수를 제한


구문 별 문법


  
    
      
        
          LIMIT B, A
          LIMIT A OFFSET B: B번째 행부터 A개의 행 선택 (0-index)
        
      
    
  


ACID

🔗 원본 파일 보기</summary>

  </entry>

  
  <entry>
    <title>C++ 정리</title>
    <link href="https://forte-naop.github.io/posts/CPP/" rel="alternate" type="text/html" title="C++ 정리" />
    <published>2024-12-30T01:55:08+09:00</published>
  
    <updated>2024-12-30T01:55:08+09:00</updated>
  
    <id>https://forte-naop.github.io/posts/CPP/</id>
    <content type="text/html" src="https://forte-naop.github.io/posts/CPP/" />
    <author>
      <name>Forte</name>
    </author>

  
    
    <category term="Study" />
    
    <category term="Programming Language" />
    
  

  <summary>C++ 정리

Const


  상수에 관한 키워드


일반 변수에서의 const


  변수 선언시 이후 해당 변수에 대한 변경을 막는다.
  
    const 키워드 이후의 구문에 대한 변경을 막는다고 간주할 수 있다.

    // 기본 자료형(int, float 등)은 무시하고 생각
const int val = 10;
int const val = 10;
// -&amp;amp;gt; val에 대한 변경 금지

const int *val = ...;
// 이후 *val = ...; 금지
// val = ...; 가능

const int **val = ...;
// **val = ...; 금지
// *val = ...; val = ...; 가능

const int * const *val = ...;
// **v...</summary>

  </entry>

  
  <entry>
    <title>OOP 정리</title>
    <link href="https://forte-naop.github.io/posts/OOP/" rel="alternate" type="text/html" title="OOP 정리" />
    <published>2024-12-19T23:56:56+09:00</published>
  
    <updated>2024-12-19T23:56:56+09:00</updated>
  
    <id>https://forte-naop.github.io/posts/OOP/</id>
    <content type="text/html" src="https://forte-naop.github.io/posts/OOP/" />
    <author>
      <name>Forte</name>
    </author>

  
    
    <category term="Study" />
    
    <category term="OOP" />
    
  

  <summary>OOP

특징


  
    추상화

    대상의 공통적인 특성들을 묶어 표현하는 것 (abstract, interface class)
  
  
    상속

    
      기존 클래스의 속성과 메서드를 물려받는 것
      코드 재사용성과 확장성을 높임
      부모 클래스의 public, protected 멤버를 상속받는다.
    
  
  
    캡슐화

    
      데이터와 메서드를 묶고, 데이터에 대한 직접 접근을 막는 것
    
  
  
    다형성

    
      같은 이름의 메서드나 연산자가 다른 동작을 하는 것
      오버로딩과 오버라이딩을 통해 구현
        
          오버로딩: 이름은 같지만 시그니쳐가 다른 것
          ...</summary>

  </entry>

  
  <entry>
    <title>최장 공통 부분 수열</title>
    <link href="https://forte-naop.github.io/posts/LCS/" rel="alternate" type="text/html" title="최장 공통 부분 수열" />
    <published>2024-11-30T01:19:44+09:00</published>
  
    <updated>2024-11-30T01:19:44+09:00</updated>
  
    <id>https://forte-naop.github.io/posts/LCS/</id>
    <content type="text/html" src="https://forte-naop.github.io/posts/LCS/" />
    <author>
      <name>Forte</name>
    </author>

  
    
    <category term="Study" />
    
    <category term="Algorithm" />
    
  

  <summary>최장 공통 부분 수열(LCS: Longest Common Subsequence)



LCS 길이 구하기

DP[i][j]: A[..i], B[..j]까지의 LCS길이


  
    A[i] == B[j]: DP[i][j] = DP[i - 1][j - 1] + 1
  
  
    A[i] != B[j]: DP[i][j] = max(DP[i - 1][j], DP[i][j - 1])
  




LCS 문자열 구하기


  역추적 (Backtracking) 방식
DP 테이블을 이용해 (N, M)에서 (0, 0)까지 역추적하여 LCS를 복원.
    
      A[i] == B[j]이면 LCS에 포함됨 → i-1, j-1로 이동
      DP[i-1][j], DP[i][j-1]를 비교해 큰 쪽으로 이...</summary>

  </entry>

  
  <entry>
    <title>정렬 알고리즘</title>
    <link href="https://forte-naop.github.io/posts/Sort/" rel="alternate" type="text/html" title="정렬 알고리즘" />
    <published>2024-11-30T01:15:21+09:00</published>
  
    <updated>2024-11-30T01:15:21+09:00</updated>
  
    <id>https://forte-naop.github.io/posts/Sort/</id>
    <content type="text/html" src="https://forte-naop.github.io/posts/Sort/" />
    <author>
      <name>Forte</name>
    </author>

  
    
    <category term="Study" />
    
    <category term="Algorithm" />
    
  

  <summary>정렬

Bubble Sort

인접한 두 원소를 비교하여 역순이면 교환한다.

# seq = []
# 총 n번 반복
for i in range(n - 1, -1, -1):
    is_swapped = False
    # 매 반복 후에 seq[i + 1:]은 정렬된 상태이므로 
    # seq[:i] 까지만 확인
    for j in range(i):
        if seq[j] &amp;amp;gt; seq[j + 1]:
            seq[j], seq[j + 1] = seq[j + 1] &amp;amp;gt; seq[j]
            is_swapped = True
    if not is_swapped:
        break


Selection Sort

현재 i = [0, n)일 때 seq...</summary>

  </entry>

</feed>


