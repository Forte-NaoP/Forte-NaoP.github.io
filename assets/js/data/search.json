[
  
  {
    "title": "Jekyll 시행 착오들 정리",
    "url": "/posts/Trial_Error/",
    "categories": "Blogging",
    "tags": "Blog",
    "date": "2025-01-30 14:57:40 +0900",
    





    
    "snippet": "Github Pages 시행착오들  링크는 https:// 로 시작해야 htmlproofer 검사에서 오류가 나지 않음      markdown 문서에서 상대경로로 포함된 리소스는 절대 경로로 변환해줘야 함.     {% assign remote_url = \"https://raw.githubusercontent.com/Forte-NaoP/Note/ma...",
    "content": "Github Pages 시행착오들  링크는 https:// 로 시작해야 htmlproofer 검사에서 오류가 나지 않음      markdown 문서에서 상대경로로 포함된 리소스는 절대 경로로 변환해줘야 함.     {% assign remote_url = \"https://raw.githubusercontent.com/Forte-NaoP/Note/main/study/Unreal/lecture.md\" %} {% assign img_url = remote_url | remove: \"lecture.md\" | append: \"capture/\" %} {% capture remote_content %} &lt;!--remote_content 변수에 remote resource 저장 --&gt;     {% remote_include https://raw.githubusercontent.com/Forte-NaoP/Note/main/study/Unreal/lecture.md %} {% endcapture %} {{ remote_content  &lt;!--remote_content에서 상대경로로 포함된 리소스를 절대 경로로 변환 --&gt; | replace: './capture/', img_url  }}      🔗 원본 파일 보기"
  },
  
  {
    "title": "Multi-level Feedack Queue 구현하기",
    "url": "/posts/MFQ/",
    "categories": "Project, OS",
    "tags": "OS, MFQ",
    "date": "2025-01-22 17:30:53 +0900",
    





    
    "snippet": "멀티 레벨 피드백 큐(MFQ) 스케줄링코드 구조  데이터 구조          Process 구조체: 각 프로세스를 표현하는 구조체.      waitq, finishedq, global_io_q: 대기 큐, 완료 큐, 글로벌 I/O 큐.        스케줄러 클래스          SchedulerBase (추상 클래스): 스케줄러의 기본 인터페이스...",
    "content": "멀티 레벨 피드백 큐(MFQ) 스케줄링코드 구조  데이터 구조          Process 구조체: 각 프로세스를 표현하는 구조체.      waitq, finishedq, global_io_q: 대기 큐, 완료 큐, 글로벌 I/O 큐.        스케줄러 클래스          SchedulerBase (추상 클래스): 스케줄러의 기본 인터페이스 정의.      Scheduler&lt;Container&gt; (템플릿 클래스): 특정 컨테이너(RR, SRTN, FCFS)를 기반으로 스케줄링을 수행.        함수          parse_process: 입력 파일을 파싱하여 프로세스를 생성하고 대기 큐에 삽입.      add_process: 프로세스를 적절한 큐로 삽입.      process_io_queue: I/O 큐에서 작업을 수행하고 완료된 프로세스를 다시 실행 큐에 추가.      run: 전체 스케줄링 시뮬레이션 실행.      print_results: 최종 결과 출력.      print_queue_status: 현재 큐 상태 출력.      코드 동작 방식1. 초기화 단계  parse_process 함수를 통해 입력 파일에서 프로세스를 읽어 waitq에 저장.  프로세스는 도착 시간(arrival_time)을 기준으로 정렬됨.2. 실행 단계run 함수의 반복 루프에서 다음 단계가 수행된다:  새로운 프로세스 추가          waitq에서 현재 cpu_clock과 일치하는 도착 시간이 있는 프로세스를 적절한 우선순위 큐(Q0~Q3)에 추가.        CPU 스케줄링          우선순위가 높은 큐부터 실행(Q0 → Q1 → Q2 → Q3).      스케줄러의 run 함수 호출.        스케줄링 알고리즘 적용          Q0 (RR, TQ=2):                  프로세스가 최대 2개의 타임 퀀텀 동안 실행.          타임 퀀텀 초과 시 Q1로 이동.          CPU burst가 완료되면 I/O 수행.                    Q1 (RR, TQ=6):                  최대 6개의 타임 퀀텀 적용, 초과 시 Q2로 이동.                    Q2 (SRTN):                  남은 CPU burst 시간이 가장 짧은 프로세스를 우선 실행.          선점될 경우 Q3로 이동.                    Q3 (FCFS):                  선입선출(FIFO) 방식으로 처리.                      I/O 처리          global_io_q에서 프로세스를 처리하며, 해당 프로세스의 I/O 시간이 감소.      I/O가 완료되면 원래 큐보다 높은 우선순위 큐로 복귀.        프로세스 종료 확인          모든 CPU burst와 I/O가 완료되면 finishedq로 이동.      3. 최종 결과 출력print_results 함수를 통해 다음 항목을 출력한다:  프로세스의 도착 시간, 종료 시간, 반환 시간(Turnaround Time), 대기 시간(Waiting Time).  평균 반환 시간 및 대기 시간.실행 과정 예시입력 예시31 0 0 2 6 3 72 1 1 1 83 2 2 3 4 3 5 1 4출력 예시[Scheduling Results]---------------------------------------------------  PID |    Arrival |     Finish | Turnaround |   Waiting---------------------------------------------------    2 |          1 |         14 |         13 |          5    1 |          0 |         21 |         21 |          8    3 |          2 |         34 |         32 |         19---------------------------------------------------Average Turnaround Time: 22Average Waiting Time: 10.6667주요 설계 고려사항  큐 간 이동 규칙:          CPU burst가 끝나면 I/O 작업을 수행한 후 적절한 큐로 이동.      타임 퀀텀이 만료되면 하위 큐로 이동.      SRTN 큐에서는 새로운 프로세스가 들어올 때 선점 발생.        클럭 증가 규칙:          프로세스가 실행될 때만 cpu_clock이 증가하도록 구현.        I/O 처리:          I/O 큐는 별도의 글로벌 큐로 유지되며 프로세스는 일정 시간 후 실행 큐로 돌아옴.        프로세스 완료 처리:          모든 작업이 완료되면 finishedq로 이동하고 완료 시간을 기록.      🔗 원본 파일 보기"
  },
  
  {
    "title": "미니 쉘 만들기",
    "url": "/posts/Swsh/",
    "categories": "Project, C_CPP",
    "tags": "mini_shell",
    "date": "2025-01-10 17:01:45 +0900",
    





    
    "snippet": "미니쉘 (swsh) 동작 과정1. 초기 설정1.1 환경 변수 설정  custom_binary = \"./commands/bin:\"을 기존 PATH 환경 변수와 합쳐서 새로운 PATH를 설정한다.  이를 통해 사용자가 실행 파일을 ./commands/bin/ 디렉토리에서 실행할 수 있도록 함.1.2 시그널 핸들링  SIGINT (Ctrl+C)와 SIGTS...",
    "content": "미니쉘 (swsh) 동작 과정1. 초기 설정1.1 환경 변수 설정  custom_binary = \"./commands/bin:\"을 기존 PATH 환경 변수와 합쳐서 새로운 PATH를 설정한다.  이를 통해 사용자가 실행 파일을 ./commands/bin/ 디렉토리에서 실행할 수 있도록 함.1.2 시그널 핸들링  SIGINT (Ctrl+C)와 SIGTSTP (Ctrl+Z)를 무시하도록 설정.  SIGCHLD 시그널을 처리하여 종료된 자식 프로세스를 정리하는 핸들러 chld_handler 등록.2. 입력 및 파싱2.1 사용자 입력 처리  read(0, input, 256)을 이용해 최대 256바이트까지 입력을 읽음.  입력을 split_commands(input, &amp;cmd_cnt)로 분리하여 명령어 목록을 생성.2.2 명령어 파싱 (argparse.c)  split_commands 함수:          | 기호를 기준으로 명령어를 여러 개로 분리함.      parse_redirection을 사용해 &gt;, &lt;, &gt;&gt; 등 입출력 리다이렉션을 처리.      parse_command를 통해 명령어와 인자를 파싱하여 COMMAND 구조체에 저장.      3. 명령 실행3.1 파이프 설정  명령어 개수(cmd_cnt)를 확인하고 필요하면 pipe(pipe_fds)를 생성.  prev_pipe_fd를 이용하여 이전 명령의 출력을 현재 명령의 입력으로 연결.3.2 명령 실행 과정  각 명령을 fork()하여 자식 프로세스를 생성한 후 실행.  setup_redirection을 이용해 입력/출력 리다이렉션을 처리.  execvp(cmd-&gt;cmd, cmd-&gt;argv)를 호출하여 실행 파일을 실행.  파이프의 읽기/쓰기 파일 디스크립터를 적절히 닫음.  waitpid(-1, &amp;status, 0)를 이용해 자식 프로세스가 종료될 때까지 대기.3.3 내부 명령 실행 (inline.c)  cd, pwd, exit는 별도로 fork() 없이 실행.          cd: chdir(path)를 호출하여 현재 디렉토리를 변경.      pwd: getcwd()를 호출하여 현재 디렉토리를 출력.      exit: exit(status)를 호출하여 쉘 종료.      4. 정리 및 종료  실행이 끝난 후 restore_redirection을 호출하여 원래의 표준 입력/출력 상태 복구.  COMMAND_free를 이용해 동적 할당된 메모리를 해제.  free(cmds)를 호출하여 COMMAND 목록을 해제.  다음 입력을 기다리며 루프를 반복.🔗 원본 파일 보기"
  },
  
  {
    "title": "웹페이지 제목 수집기",
    "url": "/posts/Title_Collector/",
    "categories": "Project, C_CPP",
    "tags": "Title_Collector",
    "date": "2025-01-04 16:59:17 +0900",
    





    
    "snippet": "구현 정리1. 구성 요소1.1 TaskQueuewget 작업을 다루는 Task Queue  헤더: task_queue.h  구현: task_queue.c함수:  TaskQueue_init: TaskQueue 초기화.  TaskQueue_push: Task 추가.  TaskQueue_pop: Task를 Queue에서 하나 꺼냄.  TaskQueue_de...",
    "content": "구현 정리1. 구성 요소1.1 TaskQueuewget 작업을 다루는 Task Queue  헤더: task_queue.h  구현: task_queue.c함수:  TaskQueue_init: TaskQueue 초기화.  TaskQueue_push: Task 추가.  TaskQueue_pop: Task를 Queue에서 하나 꺼냄.  TaskQueue_destroy: Queue에서 사용한 자원을 정리.Task Structure:typedef struct Task {    char url[MAX_DOMAIN_SIZE];    char filename[16];    bool final; // 스레드 종료를 위한 작업 종료 지시자    struct Task *next;} Task;1.2 스레드 풀wget 작업을 병렬로 처리하기 위한 스레드 풀  헤더: task_queue.h  구현: task_queue.c함수:  thread_pool_init: 스레드 풀 초기화.  thread_pool_add_task: Task Queue에 Task 추가.  thread_pool_wait: 모든 Task 끝날 때까지 대기.  thread_pool_destroy: 큐에 종료 Task를 추가해 모든 스레드 종료 후 자원 정리.1.3 메모리 풀수집한 Domain, Title 쌍을 저장하기 위한 BST 전용 메모리 풀  헤더: memory_pool.h  구현: memory_pool.c함수:  MemoryPool_init: 메모리 풀 초기화.  MemoryPool_alloc: 메모리 풀에서 자원 할당.  MemoryPool_free: 메모리 풀로 자원 반환.  MemoryPool_destroy: 메모리 풀 정리.1.4 Binary Search Tree (BST)수집한 Domain, Title 쌍을 이진 탐색 트리 형태로 저장  헤더: bst.h  구현: bst.c함수:  BST_new: BST 노드 생성.  BST_insert: Domain, Title 쌍 추가.  BST_search: Domain 검색.  BST_print_inorder: 디버깅 용 BST Inorder 출력 함수.1.5 Collect과제에서 요구하는 기능들 집합  헤더: collect.h  구현: collect.c함수:  wget: 페이지를 다운로드하고 title을 추출해서 BST에 저장.  find_title: HTML file에서 title 태그 추출.  get_domain_name: URL에서 Domain Name을 추출.  concat_string: 여러 개의 문자열을 연걸.1.6 BackupStackload 명령 실행 시 남아있던 기존 명령을 스택에 백업함  구현: main.c함수:  backup: 남은 명령을 입력으로부터 저장.  restore: 저장된 명령을 입력으로 복원.2. 작업 흐름  명령어를 읽어들임.          읽지 못했을 경우                  현재 입력이 표준 입력이고 남은 명령어가 없을 경우 자원을 정리하고 종료          리다이렉트 됐을 경우                          남은 명령어가 없으면 표준 입력으로 복구              남았을 경우 명령어 백업으로부터 복구                                          읽었을 경우 개행문자 기준으로 토큰화        작업 수행          URL의 경우, thread_pool에 작업 추가      print, stat의 경우 모든 thread 작업 완료 대기 후 명령 수행      load의 경우 load 이후에 남아있는 명령 백업 후 입력 리다이렉션 및 1번으로 이동      quit의 경우 자원 정리 후 종료      🔗 원본 파일 보기"
  },
  
  {
    "title": "string.h 직접 구현하기",
    "url": "/posts/Stringh/",
    "categories": "Project, C_CPP",
    "tags": "string.h",
    "date": "2025-01-03 16:40:20 +0900",
    





    
    "snippet": "문자열 라이브러리 구현1. 개요  C 표준 라이브러리의 &lt;string.h&gt; 및 기타 문자열 관련 함수들을 직접 구현.  앞으로의 과제를 위해 문자열 처리와 변환 함수들을 준비.2. 구현 함수2.1 숫자 변환 (Conversions)문자열 → 숫자  int atoi2(const char *str):          문자열 str을 int로 변...",
    "content": "문자열 라이브러리 구현1. 개요  C 표준 라이브러리의 &lt;string.h&gt; 및 기타 문자열 관련 함수들을 직접 구현.  앞으로의 과제를 위해 문자열 처리와 변환 함수들을 준비.2. 구현 함수2.1 숫자 변환 (Conversions)문자열 → 숫자  int atoi2(const char *str):          문자열 str을 int로 변환.      int는 32비트 정수로 간주.        long atol2(const char *str):          문자열 str을 long으로 변환.      long은 64비트 정수로 간주.      숫자 → 문자열  char *int2str(char *dest, int num):          정수 num을 문자열로 변환 후 dest에 저장.      dest가 NULL일 경우, 동적으로 메모리를 할당하여 반환.      메모리 할당 실패 시 NULL 반환.      2.2 문자열 조작 (String Manipulation)  char *strcpy(char *dst, const char *src):          문자열 src를 dst로 복사.        char *strncpy(char *dst, const char *src, size_t count):          src에서 최대 count 바이트를 dst로 복사.        char *strcat(char *dst, const char *src):          dst 문자열의 끝에 src를 붙임.        char *strncat(char *dst, const char *src, size_t count):          dst 문자열의 끝에 최대 count 바이트만큼 src를 붙임.        char *strdup(const char *str):          문자열 str을 복사하여 동적 메모리에 저장하고 해당 포인터 반환.      2.3 문자열 검사 (String Examination)  size_t strlen(const char *str):          문자열 str의 길이를 반환.        int strcmp(const char *lhs, const char *rhs):          두 문자열 lhs와 rhs를 비교.        int strncmp(const char *lhs, const char *rhs, size_t count):          lhs와 rhs를 최대 count 바이트만큼 비교.        char *strchr(const char *str, int ch):          str에서 문자 ch가 처음 나타나는 위치를 반환.        char *strrchr(const char *str, int ch):          str에서 문자 ch가 마지막으로 나타나는 위치를 반환.        char *strpbrk(const char *str, const char *accept):          str에서 accept 문자열 중 하나라도 처음 등장하는 위치를 반환.        char *strstr(const char *str, const char *substr):          str에서 부분 문자열 substr이 처음 나타나는 위치를 반환.        char *strtok(char *str, const char *delim):          str을 delim으로 토큰화.        char *strtok_r(char *str, const char *delim, char **saveptr):          strtok와 동일하지만, 내부 상태 대신 saveptr에 저장.      2.4 메모리 조작 (Memory Manipulation)  void *memcpy(void *dest, const void *src, size_t n):          src에서 dest로 n 바이트 복사.        void *memset(void *dest, int ch, size_t count):          dest에서 count 바이트를 ch로 설정.      4. 구현 제한 사항  C 표준 라이브러리 및 기타 외부 라이브러리 함수 사용 금지.  허용된 함수:          malloc, calloc, free를 포함한 일부 메모리 관리 함수.        필요한 경우 라이브러리 함수를 직접 구현 가능.  동적으로 할당된 모든 자원은 프로그램 종료 전에 반드시 해제.🔗 원본 파일 보기"
  },
  
  {
    "title": "Udemy Unreal 메모",
    "url": "/posts/Unreal/",
    "categories": "Study, Unreal",
    "tags": "Unreal",
    "date": "2025-01-01 13:50:56 +0900",
    





    
    "snippet": "# Lecture NoteUdemy 강의 (https://www.udemy.com/course/unrealcourse-korean/)Object  데이터와 기능의 집합  액터: 레벨에 들어가는 오브젝트  컴포넌트: 액터에 들어가는 오브젝트  블루프린트에서 참조 방법          화면 안의 액터 선택 후 BP의 이벤트 그래프에서 우클릭 후 Creat...",
    "content": "# Lecture NoteUdemy 강의 (https://www.udemy.com/course/unrealcourse-korean/)Object  데이터와 기능의 집합  액터: 레벨에 들어가는 오브젝트  컴포넌트: 액터에 들어가는 오브젝트  블루프린트에서 참조 방법          화면 안의 액터 선택 후 BP의 이벤트 그래프에서 우클릭 후 Create a Reference 선택        Data Pin: BP 노드의 In/Out  Execution Pin: 노드의 실행 흐름BP &amp; Instance액터 선택 후 오른쪽의 디테일 혹은 툴바에서 BP 클래스로 변환 가능하다.BP 편집 화면에서 해당 클래스의 여러 속성들을 편집할 수 있으며컨텐츠 드로어에서 씬에 드래그하는 식으로 해당 BP클래스의 인스턴스를 생성할 수 있다.Spawn BPclass : 스폰할 액터의 클래스transform : location, rotation, scalecollision : 스폰 지점 충돌 처리instigator : 이벤트 리스너여러 데이터 타입이 결합된 핀의 경우, 우클릭해서 핀 분할을 통해 세부 타입으로 분리할 수 있다.SpawnActor는 스폰한 인스턴스의 참조를 반환한다. 해당 참조를 이용해 추가적인 작업이 가능하다.Control Rotation  Get Control Rotation : 컨트롤러의 회전 벡터를 반환한다.  Get Forward Vector : 회전 벡터를 정면 벡터로 변환환다.          Forward Vector: 객체의 정면 방향을 월드 좌표계에서 나타낸 단위 벡터      Rotator : 객체의 회전을 표한하는 벡터        물체를 기준으로 바라봤을 때 좌우 회전(Z축 중심)을 Yaw, 상하 회전(Y축 중심)을 Pitch, 물체의 수평 기울기(X축 중심)을 Roll이라고 한다.      Pure Function  side effect가 없는 함수  BP 상에서 실행 핀이 없는 함수🔗 원본 파일 보기"
  },
  
  {
    "title": "SQL 메모",
    "url": "/posts/SQL/",
    "categories": "Study, Database",
    "tags": "SQL",
    "date": "2024-12-30 01:59:01 +0900",
    





    
    "snippet": "Database MEMOSQL 구문 해석 순서  FROM: 데이터 소스를 지정  ON: 조인 조건을 설정  JOIN: 필요한 테이블 결합  WHERE: 행을 필터링  GROUP BY: 데이터를 그룹화  HAVING: 그룹화된 데이터에 추가 조건 적용  SELECT: 선택한 컬럼을 가져옴  DISTINCT: 중복된 행 제거  ORDER BY: 결과를 정...",
    "content": "Database MEMOSQL 구문 해석 순서  FROM: 데이터 소스를 지정  ON: 조인 조건을 설정  JOIN: 필요한 테이블 결합  WHERE: 행을 필터링  GROUP BY: 데이터를 그룹화  HAVING: 그룹화된 데이터에 추가 조건 적용  SELECT: 선택한 컬럼을 가져옴  DISTINCT: 중복된 행 제거  ORDER BY: 결과를 정렬  LIMIT: 결과의 개수를 제한구문 별 문법                              LIMIT B, A          LIMIT A OFFSET B: B번째 행부터 A개의 행 선택 (0-index)                    ACID🔗 원본 파일 보기"
  },
  
  {
    "title": "C++ 정리",
    "url": "/posts/CPP/",
    "categories": "Study, Programming Language",
    "tags": "C++",
    "date": "2024-12-30 01:55:08 +0900",
    





    
    "snippet": "C++ 정리Const  상수에 관한 키워드일반 변수에서의 const  변수 선언시 이후 해당 변수에 대한 변경을 막는다.      const 키워드 이후의 구문에 대한 변경을 막는다고 간주할 수 있다.    // 기본 자료형(int, float 등)은 무시하고 생각const int val = 10;int const val = 10;// -&gt; va...",
    "content": "C++ 정리Const  상수에 관한 키워드일반 변수에서의 const  변수 선언시 이후 해당 변수에 대한 변경을 막는다.      const 키워드 이후의 구문에 대한 변경을 막는다고 간주할 수 있다.    // 기본 자료형(int, float 등)은 무시하고 생각const int val = 10;int const val = 10;// -&gt; val에 대한 변경 금지const int *val = ...;// 이후 *val = ...; 금지// val = ...; 가능const int **val = ...;// **val = ...; 금지// *val = ...; val = ...; 가능const int * const *val = ...;// **val = ...; *val = ...; 금지// val = ...; 가능      함수에서의 const  반환형, 매개변수의 const는 일반 변수와 동일  멤버 함수의 경우 함수 시그니쳐 이후에 const를 사용할 수 있다.      const 멤버 함수의 제약조건은 다음과 같다.      class MyClass {  private:      int value = 10;      mutable int mutableValue = 0;      static int staticValue;  public:      int getValue() { // non-const 멤버 함수          return value;      }      void SetValue(int val) const { // const 멤버 함수          value = val; // 일반 멤버 변수 수정 불가          staticValue = mutableValue = 1; // static, mutable 멤버 변수 수정 가능      }      bool IsPositive() const { // const 멤버 함수          int val = GetValue();  // 일반 멤버 함수 호출 불가          SetValue(0); // const 멤버 함수 호출 가능          GetStaticValue(); // static 멤버 함수 호출 가능          externalFunction(value); // 외부 함수 호출 가능          return value &gt; 0;         }      static int GetStaticValue() {          staticValue = 10; // static 멤버 함수는 static 멤버 함수/변수만 접근 가능          return staticValue;      }  };  // 외부 함수  void externalFunction(int&amp; val) {      val = 50;  }  int MyClass::staticValue = 0;       상속, 다형성, Virtual  상속: 부모 클래스의 속성이나 메소드를 자식 클래스가 물려 받는 것.코드 재사용성 증가, 객체 모델링 유연성 증가      다형성: 같은 이름의 메소드나 연산자가 다른 클래스에 대해 다른 동작을 하는 것    타입 캐스팅                  업 캐스팅과 Virtual 키워드다형성을 위해 자식 클래스를 부모 클래스로 변환하는 경우                    다운 캐스팅과 RTTI부모 클래스의 객체를 자식 클래스로 변환하는 경우dynamic_cast를 이용해 수행되며 런타임에 객체의 타입을 확인 후, 불가능한 경우 포인터는 nullptr 반환, 참조자는 std::bad_cast 예외를 던진다.              class Animal {  public:      virtual void says() { cout &lt;&lt; \"Animal says\" &lt;&lt; endl; }      void what() { cout &lt;&lt; \"Animal\" &lt;&lt; endl; }};  class Dog : public Animal {  public:      void says() override { cout &lt;&lt; \"Dog says\" &lt;&lt; endl; }      void what() { cout &lt;&lt; \"Dog\" &lt;&lt; endl; }  };  Animal* a = new Animal();  Animal* b = new Dog();  a-&gt;says(); // Animal says  a-&gt;what(); // Animal  b-&gt;says(); // Dog says  b-&gt;what(); // Animal              Dog 클래스의 인스턴스를 부모인 Animal로 업캐스팅했다.함수 호출 결과를 보면 virtual 함수인 says는 원본 클래스의 함수를 잘 호출하지만 what은 부모 클래스의 함수만 호출된다.      virtual 함수가 있는 클래스는 컴파일 과정에서 VTable을 생성해 함수 호출을 관리한다.      VTable은 클래스마다 생성되며 객체는 VTable 포인터를 통해 자신의 클래스의 함수를 호출하게 된다.      non virtual 함수는 컴파일 타임에 정적으로 바인딩된다.              가상 함수가 포함된 클래스의 메모리 레이아웃은 다음과 같다.        Animal 객체 메모리 레이아웃:+----------------------------+| Animal 클래스 RTTI 포인터   |+----------------------------+| Animal 클래스 VTable 포인터 | &lt;-- a가 여길 가리키고 있음+----------------------------+| (Animal 클래스 멤버 변수)   |+----------------------------+      Dog 객체 메모리 레이아웃:+----------------------------+| Dog 클래스 RTTI 포인터      |+----------------------------+| Dog 클래스 VTable 포인터    |  &lt;-- b가 여길 가리키고 있음+----------------------------+| (Animal 클래스 멤버 변수)   |  +----------------------------+| (Dog 클래스 멤버 변수)      |+----------------------------+Animal VTable:+-----------------+| &amp;Animal::speak  |  // Animal의 says() 함수 주소+-----------------+      Dog VTable:+-----------------+| &amp;Dog::speak     |  // Dog의 says() 함수 주소+-----------------+                          해당 메모리 레이아웃은 다음과 같은 방법으로도 확인 할 수 있다.                class A {    private:        int A_num;        int A_sum;    public:        A() {             A_num = 0x12121212;            A_sum = 0x34343434;            printf(\"A 생성자\\n\");         }        virtual void says() { printf(\"A의 func\\n\"); }        virtual ~A() { printf(\"A 소멸자\\n\"); }            };class B : public A {    private:        int B_num;        int B_sum;    public:        B() {             B_num = 0x56565656;            B_sum = 0x78787878;            printf(\"B 생성자\\n\");         }        void says() override { printf(\"B의 func\\n\"); }        ~B() { printf(\"B 소멸자\\n\"); }};A* c = new B();uintptr_t* vtablePtr = *reinterpret_cast&lt;uintptr_t**&gt;(c); // vtable 포인터printf(\"vtablePtr: %p\\n\", vtablePtr);int* dataPtr = reinterpret_cast&lt;int*&gt;(reinterpret_cast&lt;char*&gt;(c) + sizeof(uintptr_t));printf(\"A_num: %x\\n\", *dataPtr);dataPtr = reinterpret_cast&lt;int*&gt;(reinterpret_cast&lt;char*&gt;(c) + sizeof(uintptr_t) + sizeof(int)); printf(\"A_sum: %x\\n\", *dataPtr);dataPtr = reinterpret_cast&lt;int*&gt;(reinterpret_cast&lt;char*&gt;(c) + sizeof(uintptr_t) + sizeof(int) * 2);printf(\"B_num: %x\\n\", *dataPtr);dataPtr = reinterpret_cast&lt;int*&gt;(reinterpret_cast&lt;char*&gt;(c) + sizeof(uintptr_t) + sizeof(int) * 3);printf(\"B_sum: %x\\n\", *dataPtr);auto funcPtr = reinterpret_cast&lt;void(*)(A*)&gt;(vtablePtr[0]);funcPtr(c);cout &lt;&lt; typeid(*c).name() &lt;&lt; endl;const std::type_info* rttiInfo = reinterpret_cast&lt;const std::type_info*&gt;(vtablePtr[-1]);std::cout &lt;&lt; \"RTTI type name: \" &lt;&lt; rttiInfo-&gt;name() &lt;&lt; std::endl;// 출력 결과// A 생성자// B 생성자// vtablePtr: 0x5631eb7cbcc0// A_num: 12121212// A_sum: 34343434// B_num: 56565656// B_sum: 78787878// B의 func// RTTI type name: 1B                            소멸자도 함수이기 때문에 소멸자를 가상 함수로 선언하지 않으면 부모 클래스의 소멸자만 호출되어 메모리 누수가 발생할 수 있다.            순수 가상 함수                  가상 함수를 선언만 한 형태                virtual void func() = 0;                          순수 가상 함수가 하나라도 있는 클래스는 추상 클래스라 하며 해당 클래스는 객체 생성이 불가능하다.          순수 가상 함수는 상속된 클래스에서 반드시 구현해줘야 함          순수 가상 함수로만 이루어진 클래스는 인터페이스라고 함                    포인터와 참조자            특징      포인터      참조자                  NULL 지원      지원 (nullptr)      지원하지 않음              초기화      나중에 초기화 가능      선언과 동시에 초기화 필수              대상 변경      가능      불가능              사용법      *, &amp; 필요      간단 (변수처럼 사용 가능)              크기      메모리 주소 크기      크기 없음              산술 연산      가능 (ptr++)      불가능      선택 기준  포인터를 사용할 때:          동적 메모리 할당 및 관리가 필요할 때      NULL 값을 가리키거나 가리키는 대상을 변경해야 할 때      배열, 문자열, 하드웨어 주소를 다룰 때        참조자를 사용할 때:          매개변수로 데이터를 전달하여 복사를 피하고 싶을 때      반환값으로 객체를 참조해야 할 때      간단하고 직관적인 코드를 작성하고 싶을 때      객체의 초기화C++에서 클래스 생성자는 객체가 생성될 때 호출되어 멤버 변수나 기타 자원을 초기화하는 특별한 함수다.1. 멤버 초기화 리스트(Member Initialization List)  생성자 정의에서 콜론(:) 뒤에 멤버 초기화 리스트를 사용하여 객체를 초기화  멤버 변수의 초기화가 생성자의 본체가 실행되기 전에 수행되므로 효율적  const 멤버, 참조자 멤버는 생성 시 초기화 되어야 하므로 초기화 리스트가 필수class MyClass {private:    int value;    const int constValue;    int&amp; refValue;public:    MyClass(int val, int constVal, int&amp; ref)         : value(val), constValue(constVal), refValue(ref) {}};2. 생성자 본문에서 초기화  생성자 본문에서 직접 멤버 변수에 값을 할당하여 초기화.  임시 객체 생성 가능성이 있class MyClass {private:    int value;public:    MyClass(int val) {        value = val;    }};3. 디폴트 멤버 초기화(Default Member Initializer)  C++11부터 클래스 정의에서 멤버 변수를 초기화할 수 있는 디폴트 초기화 구문이 도입  멤버 변수 선언 시 초기값을 지정하며, 모든 생성자에서 동일한 초기값을 사용하려는 경우 유용함  초기화 리스트보다 우선 적용되지만, 명시적 초기화가 있으면 덮어쓴다.class MyClass {private:    int value = 0;    double rate = 1.5;public:    MyClass() {} // 별도 초기화 없이 기본값 사용};4. 위임 생성자(Delegating Constructor)  C++11에서 추가된 기능으로, 생성자에서 다른 생성자를 호출하여 멤버를 초기화  비슷한 초기화 로직을 여러 생성자에서 반복하지 않고 공유할 수 있다.  코드 중복을 줄이고, 유지보수성을 높임class MyClass {private:    int value;public:    // 기본 생성자    MyClass() : MyClass(0) {} // 위임 생성자 사용    // 파라미터를 받는 생성자    MyClass(int val) : value(val) {}};L-Value, R-Value, Move Semantics  L-Value: 메모리에 존재하며 참조할 수 있는 값  R-Value: 임시적인 값으로 참조할 수 없는 값  Move semantics: 복사 대신 리소스의 소유권을 이동하는 개념          R-Value 참조(&amp;&amp;): R-Value를 참조할 수 있는 참조자      std::move: L-Value를 R-Value 캐스팅해주는 함수        이동 생성자와 이동 대입 연산자를 구현하여 사용    복사 대신 소유권을 이전하여 기존 객체의 리소스를 재활용원본 객체는 비어있는 상태가 됨    불필요한 메모리 할당과 해제를 줄여 복사 오버헤드를 줄이고 효율적인 메모리 사용을 가능하게 한다.    class MyClass {private:    int* data;    int size;public:    MyClass(int s) : size(s), data(new int[s]) { }    // 이동 생성자    MyClass(MyClass&amp;&amp; other) noexcept : size(other.size), data(other.data) {        other.size = 0;        other.data = nullptr;  // 소유권 이전    }    // 이동 대입 연산자    MyClass&amp; operator=(MyClass&amp;&amp; other) noexcept {        if (this != &amp;other) {            delete[] data;  // 기존 리소스 해제            data = other.data;            size = other.size;            other.data = nullptr;            other.size = 0;        }        return *this;    }    ~MyClass() { delete[] data; }  };int main() {    MyClass obj1(10);    MyClass obj2 = std::move(obj1);  // 이동 생성자 호출    MyClass obj3(5);    obj3 = std::move(obj2);  // 이동 대입 연산자 호출    return 0;}      🔗 원본 파일 보기"
  },
  
  {
    "title": "OOP 정리",
    "url": "/posts/OOP/",
    "categories": "Study, OOP",
    "tags": "OOP",
    "date": "2024-12-19 23:56:56 +0900",
    





    
    "snippet": "OOP특징      추상화    대상의 공통적인 특성들을 묶어 표현하는 것 (abstract, interface class)        상속          기존 클래스의 속성과 메서드를 물려받는 것      코드 재사용성과 확장성을 높임      부모 클래스의 public, protected 멤버를 상속받는다.            캡슐화      ...",
    "content": "OOP특징      추상화    대상의 공통적인 특성들을 묶어 표현하는 것 (abstract, interface class)        상속          기존 클래스의 속성과 메서드를 물려받는 것      코드 재사용성과 확장성을 높임      부모 클래스의 public, protected 멤버를 상속받는다.            캡슐화          데이터와 메서드를 묶고, 데이터에 대한 직접 접근을 막는 것            다형성          같은 이름의 메서드나 연산자가 다른 동작을 하는 것      오버로딩과 오버라이딩을 통해 구현                  오버로딩: 이름은 같지만 시그니쳐가 다른 것          오버라이딩: 상위 클래스의 메소드를 재정의 하는 것                    SOLID 원칙      단일 책임 원칙 (SRP)    클래스는 단 하나의 책임을 가지고 하나의 이유로만 변경되어야 한다.        개방 폐쇄 원칙 (OCP)    확장에는 열려 있고 수정에는 닫혀 있어야 한다. 기존 코드를 수정하지 않고 기능을 추가할 수 있어야 한다.        리스코프 치환 원칙 (LSP)    상위 타입의 객체를 하위 타입으로 대체해도 정상적으로 동작해야 한다.        인터페이스 분리 원칙 (ISP)    클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다. 인터페이스를 세분화하여 클라이언트가 필요한 기능만 사용할 수 있도록 제한한다.        의존성 역전 원칙 (DIP)    고수준 모듈(비즈니스 로직 등)은 저수준 모듈(구현 세부 사항)에 의존해서는 안 된다. 고수준, 저수준 모두 둘 다 추상화(인터페이스나 추상 클래스)에 의존해야 한다.    DIP 위반     class EmailService {     public:         void SendEmail(const string&amp; message) {             cout &lt;&lt; \"Sending Email: \" &lt;&lt; message &lt;&lt; endl;         } }; // 고수준 모듈: Notification은 EmailService에 직접 의존 class Notification {     private:         EmailService emailService; // 저수준 모듈에 직접 의존     public:         void Notify(const string&amp; message) {             emailService.SendEmail(message); // EmailService에 직접 접근         } };        DIP 적용     class IMessageService {     public:         virtual void SendMessage(const std::string&amp; message) = 0; }; // 고수준 모듈 class Notification {     private:         IMessageService* messageService;     public:         Notification(IMessageService* service) : messageService(service) {}         void Notify(const std::string&amp; message) {             messageService-&gt;SendMessage(message);         } }; // 저수준 모듈 class EmailService : public IMessageService {     public:         void SendMessage(const std::string&amp; message) override {             // 이메일 전송 로직         } };      🔗 원본 파일 보기"
  },
  
  {
    "title": "OS Scheduling",
    "url": "/posts/OS_Scheduling/",
    "categories": "Study, OS",
    "tags": "Scheduling",
    "date": "2024-12-19 13:50:56 +0900",
    





    
    "snippet": "# OSScheduling  자원을 할당받을 프로세스를 결정하는 과정  Process 5-state model  다음 경우에 발생          Running -&gt; Blocked (Waiting)      Running -&gt; Ready      Blocked (Waiting) -&gt; Ready      Exit(Terminated)  ...",
    "content": "# OSScheduling  자원을 할당받을 프로세스를 결정하는 과정  Process 5-state model  다음 경우에 발생          Running -&gt; Blocked (Waiting)      Running -&gt; Ready      Blocked (Waiting) -&gt; Ready      Exit(Terminated)        이 중 1, 4번에서만 발생할 경우 비선점 (non-preemptive), 네 가지 전부에서 발생할 경우 선점 (preemptive) 스케줄링이라 한다.  알고리즘First Come First Served (FCFS, FIFO)  가장 간단한 비선점 스케줄링 방법  작업 큐에 도착한 순서대로 실행한다.  작업 순서에 따라 콘보이 효과가 발생 할 수 있다.          콘보이 효과: 하나의 긴 작업이 CPU를 오래 점유하여 뒤에 대기하는 짧은 작업들이 오래 기다리게 되는 현상      Shortest Job First (SJB)  비선점  실행 시간(burst time)이 짧은 프로세스부터 실행  어떤 프로세스가 계속 자원 할당을 받지 못하는 Starvation 발생 가능Shortest Remaining Time First (SRTF)  선점형  남은 시간이 가장 짧은 프로세스부터 실행  Starvation 발생 가능Priority Scheduling  선점형, 비선점형  선점형의 경우 Starvation 발생 가능          오래 대기한 프로세스의 우선순위를 높여서 해결 가능 (aging)      Round Robin (RR)  선점형  일정한 시간 간격동안만 프로세스를 처리하고 남은 작업은 큐의 맨 뒤로 보냄Multilevel Feedback Queue  선점형  우선순위가 다른 여러개의 큐를 사용  프로세스는 다른 큐로 이동 가능🔗 원본 파일 보기"
  },
  
  {
    "title": "최장 공통 부분 수열",
    "url": "/posts/LCS/",
    "categories": "Study, Algorithm",
    "tags": "DP, LCS",
    "date": "2024-11-30 01:19:44 +0900",
    





    
    "snippet": "최장 공통 부분 수열(LCS: Longest Common Subsequence)LCS 길이 구하기DP[i][j]: A[..i], B[..j]까지의 LCS길이      A[i] == B[j]: DP[i][j] = DP[i - 1][j - 1] + 1        A[i] != B[j]: DP[i][j] = max(DP[i - 1][j], DP[i][j ...",
    "content": "최장 공통 부분 수열(LCS: Longest Common Subsequence)LCS 길이 구하기DP[i][j]: A[..i], B[..j]까지의 LCS길이      A[i] == B[j]: DP[i][j] = DP[i - 1][j - 1] + 1        A[i] != B[j]: DP[i][j] = max(DP[i - 1][j], DP[i][j - 1])  LCS 문자열 구하기  역추적 (Backtracking) 방식DP 테이블을 이용해 (N, M)에서 (0, 0)까지 역추적하여 LCS를 복원.          A[i] == B[j]이면 LCS에 포함됨 → i-1, j-1로 이동      DP[i-1][j], DP[i][j-1]를 비교해 큰 쪽으로 이동      def LCS(A: str, B: str) -&gt; str:    N, M = len(A), len(B)    DP = [[0] * (M + 1) for _ in range(N + 1)]    # DP 테이블 채우기    for i in range(1, N + 1):        for j in range(1, M + 1):            if A[i - 1] == B[j - 1]:  # 문자가 같으면                DP[i][j] = DP[i - 1][j - 1] + 1            else:                DP[i][j] = max(DP[i - 1][j], DP[i][j - 1])    # LCS 역추적 (Backtracking)    i, j = N, M    lcs = []    while i &gt; 0 and j &gt; 0:        if A[i - 1] == B[j - 1]:  # 같은 문자는 LCS에 포함            lcs.append(A[i - 1])            i -= 1            j -= 1        elif DP[i - 1][j] &gt; DP[i][j - 1]:  # 위쪽이 크다면 위로 이동            i -= 1        else:  # 왼쪽이 크다면 왼쪽으로 이동            j -= 1    return ''.join(reversed(lcs))  # 역순으로 정렬하여 반환시간 복잡도  DP 테이블을 채우는 과정: O(N × M)  LCS 역추적 과정: O(N + M)  전체 시간 복잡도: O(N × M)🔗 원본 파일 보기"
  },
  
  {
    "title": "정렬 알고리즘",
    "url": "/posts/Sort/",
    "categories": "Study, Algorithm",
    "tags": "Sort",
    "date": "2024-11-30 01:15:21 +0900",
    





    
    "snippet": "정렬Bubble Sort인접한 두 원소를 비교하여 역순이면 교환한다.# seq = []# 총 n번 반복for i in range(n - 1, -1, -1):    is_swapped = False    # 매 반복 후에 seq[i + 1:]은 정렬된 상태이므로     # seq[:i] 까지만 확인    for j in range(i):        i...",
    "content": "정렬Bubble Sort인접한 두 원소를 비교하여 역순이면 교환한다.# seq = []# 총 n번 반복for i in range(n - 1, -1, -1):    is_swapped = False    # 매 반복 후에 seq[i + 1:]은 정렬된 상태이므로     # seq[:i] 까지만 확인    for j in range(i):        if seq[j] &gt; seq[j + 1]:            seq[j], seq[j + 1] = seq[j + 1] &gt; seq[j]            is_swapped = True    if not is_swapped:        breakSelection Sort현재 i = [0, n)일 때 seq[i:]에서 가장 작은 원소와 seq[i]를 교환한다.# seq = []for cur in range(n):    min_index = cur    for i in range(cur, n):        if seq[min_index] &gt; seq[i]:            min_index = i    seq[min_index], seq[cur] = seq[cur], seq[min_index]Insertion Sort현재 i = [1, n)일 때 seq[:i]에서 seq[i]를 삽입할 위치를 찾아 삽입한다.# seq = []for cur in range(1, n):    while cur &gt; 0 and seq[cur] &lt; seq[cur - 1]:        seq[cur], seq[cur - 1] = seq[cur - 1], seq[cur]        cur -= 1Quick Sortpivot을 기준으로 배열을 양쪽으로 나누어 정렬한다.# seq = []def partition(left, right):    # [left, right] 범위를 재배치    pivot = seq[(left + right) // 2]    while left &lt;= right:        # left를 pivot보다 큰 원소가 나타나는 지점까지 이동        while seq[left] &lt; pivot:            left += 1        # right를 pivot보다 작은 원소가 나타나느 지점까지 이동        while seq[right] &gt; pivot:            right -= 1                # 재배치가 안끝났으면        if left &lt;= right:            # seq[left]는 pivot보다 크고             # seq[right]는 pivot보다 작으므로             # 서로 교환            seq[left], seq[right] = seq[right], seq[left]            # 한 칸씩 이동            left, right = left + 1, right - 1    return leftdef quick_sort(left, right):    print(seq, left, right)    if left &gt;= right:        return        mid = partition(left, right)    quick_sort(left, mid - 1)    quick_sort(mid, right)Merge Sort배열을 두 부분으로 나누고 각 배열을 정렬한 뒤 하나로 합친다.# seq = []def merge(left, mid, right):    # seq[left:mid + 1]과 seq[mid + 1:right]를 합침    tmp = []    i, j = left, mid + 1    # 두 부분 배열에서 작은 값을 채워 넣음    while i &lt;= mid and j &lt;= right:        if seq[i] &lt; seq[j]:            tmp.append(seq[i])            i += 1        else:            tmp.append(seq[j])            j += 1    # 부분 배열에서 남은 것을 뒤에 추가함    while i &lt;= mid:         tmp.append(seq[i])        i += 1    while j &lt;= right:        tmp.append(seq[j])        j += 1    # 정렬된 배열을 원본 배열에 옮김    seq[left:left+len(tmp)] = tmp[:]def merge_sort(left, right):    # 길이 2 이상의 배열에 대해 분할    if left &gt;= right:        return    mid = (left + right) // 2    # 두 부분으로 나눔    merge_sort(left, mid)    merge_sort(mid + 1, right)    # 나눈 배열을 합침    merge(left, mid, right)🔗 원본 파일 보기"
  },
  
  {
    "title": "편집 거리",
    "url": "/posts/Edit_distance/",
    "categories": "Study, Algorithm",
    "tags": "DP",
    "date": "2024-11-30 01:02:24 +0900",
    





    
    "snippet": "편집 거리문자열 A를 문자열 B로 바꾸는데 필요한 연산(문자 추가, 삭제, 교체)의 최소 횟수DP[i][j]: A[..i]를 B[..j]로 편집하는 연산의 최소 횟수A[i] == B[j]라면 해당 위치에 대해서는 편집할 필요가 없으므로 DP[i][j] == DP[i - 1][j - 1]A[i] != B[j]라면 편집이 필요하다.추가하는 경우는 A[i]...",
    "content": "편집 거리문자열 A를 문자열 B로 바꾸는데 필요한 연산(문자 추가, 삭제, 교체)의 최소 횟수DP[i][j]: A[..i]를 B[..j]로 편집하는 연산의 최소 횟수A[i] == B[j]라면 해당 위치에 대해서는 편집할 필요가 없으므로 DP[i][j] == DP[i - 1][j - 1]A[i] != B[j]라면 편집이 필요하다.추가하는 경우는 A[i]에 문자열을 하나 추가해서 B[j]가 되어야 하므로 DP[i][j - 1] + 1, 즉 A[..i]를 B[..j - 1]로 변경하는 최소 횟수에 1을 더해준다.변경은 A[i]를 B[j]로 바꾸는 것이므로 DP[i - 1][j - 1] + 1삭제는 DP[i - 1][j] + 1이 된다.(A[..i - 1]로 B[j]를 만들었으므로 A[i]를 삭제)🔗 원본 파일 보기"
  },
  
  {
    "title": "위상 정렬",
    "url": "/posts/Topology_Sort/",
    "categories": "Study, Algorithm",
    "tags": "Sort",
    "date": "2024-11-30 00:01:14 +0900",
    





    
    "snippet": "위상정렬비순환 유향 그래프(DAG)에 대해서 정점을 선형으로 정렬하는 것각 노드에 선행 조건이 존재할 때 사용 가능정렬 방법  각 노드의 진입 차수 기록  진입 차수가 0인 정점을 큐에 삽입  큐에 담긴 정점에서 나가는 간선을 제거하고 해당 간선에 연결된 정점의 진입 차수를 감소  2-3과정을 큐가 비거나 모든 정점을 탐색할 때까지 반복구현graph ...",
    "content": "위상정렬비순환 유향 그래프(DAG)에 대해서 정점을 선형으로 정렬하는 것각 노드에 선행 조건이 존재할 때 사용 가능정렬 방법  각 노드의 진입 차수 기록  진입 차수가 0인 정점을 큐에 삽입  큐에 담긴 정점에서 나가는 간선을 제거하고 해당 간선에 연결된 정점의 진입 차수를 감소  2-3과정을 큐가 비거나 모든 정점을 탐색할 때까지 반복구현graph = defaultdict(list)indegree = [0] * (n + 1)# 인접 리스트 및 진입 차수 초기화# for _ in range(k):#     a, b = map(int, input().split())#     graph[a].append(b)#     indegree[b] += 1# 진입 차수 0인 정점 큐에 추가q = deque(filter(lambda x: indegree[x] == 0, range(1, n + 1)))while q:    cur = st.popleft()    print(q)    if cur in graph:        for nxt in graph[cur]:            indegree[nxt] -= 1            if indegree[nxt] == 0:                st.append(nxt)🔗 원본 파일 보기"
  },
  
  {
    "title": "블로그 소개",
    "url": "/posts/Introduce/",
    "categories": "Blogging",
    "tags": "Blog",
    "date": "2024-11-15 10:28:00 +0900",
    





    
    "snippet": "알고리즘, 자료구조 및 다양한 프로그래밍 관련 내용을 정리한 개인 학습 저장소입니다.",
    "content": "알고리즘, 자료구조 및 다양한 프로그래밍 관련 내용을 정리한 개인 학습 저장소입니다."
  }
  
]

