---
title: "고정 크기 Heap 구현"
date: "2025-01-31 07:49:01 +0900"
categories: [Study, Algorithm]
tags: [Heap]
---

# **힙(Heap)**  
**완전 이진 트리(Complete Binary Tree) 기반의 자료구조** &nbsp;
**최댓값 또는 최솟값을 빠르게 접근 및 관리**하는 데 사용된다.

---

## **1. 힙의 종류**

### 🔹 **최대 힙 (Max Heap)**

- 부모 노드는 항상 **자식보다 크거나 같음**
- 루트 노드에는 **가장 큰 값이 위치**함
- 삽입(push)과 삭제(pop) 후에도 이 속성이 유지됨

✅ 예시 (최대 힙)  

```
        50
       /  \
     30    40
    /  \   /
   10  20 35
```

- `top()`을 하면 **50**이 반환됨
- `pop()`을 하면 **50이 제거**되고, 힙 속성이 유지됨

### 🔹 **최소 힙 (Min Heap)**

- 부모 노드는 항상 **자식보다 작거나 같음**
- 루트 노드에는 **가장 작은 값이 위치**함

✅ 예시 (최소 힙)  

```
        10
       /  \
     20    30
    /  \   /
   50  40 35
```

- `top()`을 하면 **10**이 반환됨
- `pop()`을 하면 **10이 제거**되고, 힙 속성이 유지됨

---

## **2. 힙의 특징**

1. **완전 이진 트리(Complete Binary Tree)**
   - 트리의 모든 레벨이 **완전히 채워져 있어야 함**
   - 마지막 레벨만 예외적으로 **왼쪽부터 채워짐**

2. **힙 속성(Heap Property) 유지**
   - **최대 힙**: 부모 노드 ≥ 자식 노드  
   - **최소 힙**: 부모 노드 ≤ 자식 노드  

3. **빠른 삽입과 삭제**
   - `O(log N)`의 시간 복잡도를 가짐

---

## **3. 힙의 연산**

### 🔹 **삽입 (push, insert)**

1. **새로운 원소를 트리의 마지막 위치에 추가**

2. **부모 노드와 비교하여 힙 속성이 유지될 때까지 Swap (Heapify-up)**
3. **시간 복잡도: O(log N)**

✅ 예제 (최대 힙, `push(45)`)

```
초기 상태:
        50
       /  \
     30    40
    /  \   /
   10  20 35

(1) 45를 마지막에 추가:
        50
       /  \
     30    40
    /  \   / \
   10  20 35  45

(2) 부모(40)와 비교 후 Swap:
        50
       /  \
     30    45
    /  \   / \
   10  20 35  40
```

⏳ **시간 복잡도: `O(log N)`**

---

### 🔹 **삭제 (pop, remove)**

1. **루트 노드를 제거**
2. **마지막 원소를 루트로 이동**
3. **자식 노드 중 더 큰 값과 Swap하여 힙 속성을 유지 (Heapify-down)**
4. **시간 복잡도: O(log N)**

✅ 예제 (최대 힙, `pop()`)

```
초기 상태:
        50
       /  \
     30    40
    /  \   / \
   10  20 35  45

(1) 루트(50) 제거 후, 마지막 노드(45) 이동:
        45
       /  \
     30    40
    /  \   /
   10  20 35

(2) 자식 중 더 큰 값(40)과 Swap:
        45
       /  \
     30    40
    /  \   /
   10  20 35
```

⏳ **시간 복잡도: `O(log N)`**

---

## **4. 힙의 구현 방법**

### 🔹 **배열(Array) 기반 힙 구현**

힙은 **배열을 사용하여 구현**.  
노드의 **인덱스를 활용하여 부모/자식 노드를 계산**할 수 있다다.

| 노드 | 인덱스 | 부모 노드 | 왼쪽 자식 | 오른쪽 자식 |
|------|--------|----------|-----------|------------|
| Root | `1` | - | `2` | `3` |
| A    | `2` | `1` | `4` | `5` |
| B    | `3` | `1` | `6` | `7` |

**수식**

- **부모 노드:** `parent(i) = i / 2`
- **왼쪽 자식:** `left(i) = 2 * i`
- **오른쪽 자식:** `right(i) = 2 * i + 1`

## **5. 힙의 활용**

### ✅ **우선순위 큐 (Priority Queue)**

- `std::priority_queue<T>` (C++ STL) 내부적으로 **힙으로 구현**
- `O(log N)`에 삽입/삭제 가능

### ✅ **힙 정렬 (Heap Sort)**

- `O(N log N)`의 시간 복잡도
- `std::make_heap(), std::sort_heap()` 함수 활용 가능

### ✅ **다익스트라 알고리즘 (Dijkstra's Algorithm)**

- 그래프 최단 경로를 찾을 때 **우선순위 큐**를 사용하여 `O(E log V)`에 최적화 가능

## **6. C++ 구현**

```{{ "cpp" }}
{% remote_include https://raw.githubusercontent.com/Forte-NaoP/Note/main/cpp/heap.cpp %}
```
<p>🔗 <a href="https://github.com/Forte-NaoP/Note/blob/main/cpp/heap.cpp" target="_blank">원본 파일 보기</a></p>
